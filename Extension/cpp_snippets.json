{
  "class": {
    "prefix": "class",
    "body": "\nclass ${1:${TM_FILENAME_BASE}}\n{\nprivate:\n\t${2:/* data */}\npublic:\n\t${1}(${3:/* args */});\n\t~${1}();\n};\n\n${1}::${1}(${3})\n{\n}\n\n${1}::~${1}()\n{\n}\n",
    "description": "Code snippet for class",
    "scope": "source.c++, source.objc++"
  },
  "classi": {
    "prefix": "classi",
    "body": "\nclass ${1:${TM_FILENAME_BASE}}\n{\nprivate:\n\t${2:/* data */}\npublic:\n\t${1}::${1}(${3:/* args */}) { $0 }\n\t${1}::~${1}() { }\n};",
    "description": "Code snippet for class with inlined constructor/destructor",
    "scope": "source.c++, source.objc++"
  },
  "classt": {
    "prefix": "classt",
    "body": "\ntemplate<typename T>\nclass ${1:${TM_FILENAME_BASE}}\n{\nprivate:\n\tT ${2:/* data */}\npublic:\n\t${1}(T ${3:/* args */});\n};\n",
    "description": "Code snippet for class template",
    "scope": "source.c++, source.objc++"
  },
  "excep": {
    "prefix": "excep",
    "body": "\nclass ${1:${TM_FILENAME_BASE}} : public ${2:std::runtime_error}\n{\npublic:\n\t${1}(const std::string& str): ${2:std::runtime_error}(${3:str}) {}\n};\n",
    "description": "Code snippet for exception",
    "scope": "source.c++, source.objc++"
  },
  "struct": {
    "prefix": "struct",
    "body": "\nstruct ${1:${TM_FILENAME_BASE}}\n{\n\t${0:/* data */}\n};\n",
    "description": "Code snippet for struct",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "union": {
    "prefix": "union",
    "body": "\nunion ${1:${TM_FILENAME_BASE}}\n{\n\t${0:/* data */}\n};\n",
    "description": "Code snippet for union",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "structtemp": {
    "prefix": "structtemp",
    "body": "\ntemplate<typename T>\nstruct ${1:${TM_FILENAME_BASE}} {\n\tT ${0:/* data */}\n};\n",
    "description": "Code snippet for templated Struct",
    "scope": "source.c++, source.objc++"
  },

  "if": {
    "prefix": "if",
    "body": "\nif (${1:/* condition */}) {\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for if()",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "ifel": {
    "prefix": "ifel",
    "body": "\nif (${1:/* condition */}) {\n\t${2:/* code */}\n}\nelse {\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for if() else",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "ifelif": {
    "prefix": "ifelif",
    "body": "\nif (${1:/* condition */}) {\n\t${2:/* code */}\n}\nelse if(${3:/* condition */}) {\n\t${4:/* code */}\n}\nelse {\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for if() else if() else",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "else": {
    "prefix": "else",
    "body": "\nelse\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for else",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "elif": {
    "prefix": "elif",
    "body": "\nelse if (${1:/* condition */})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for else if ()",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "switch": {
    "prefix": "switch",
    "body": "\nswitch (${1:expression})\n{\n\tcase ${2:/* constant-expression */}:\n\t\t${3:/* code */}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n}",
    "description": "Code snippet for switch",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },

  "confunct": {
    "prefix": "confunc",
    "body": "\nconstexpr ${1:int} ${2:function_name}(${3:/* args */})\n{\n\treturn ${0:/* code */};\n}\n",
    "description": "Code snippet for constexpr function",
    "scope": "source.c++"
  },
  "main": {
    "prefix": "main",
    "body": "\nint main(int argc, char const *argv[])\n{\n\t${1:/* code */}\n\treturn 0;\n}\n",
    "description": "Code snippet for main()",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "func": {
    "prefix": "func",
    "body": "\n${1:int} ${2:function_name}(${3:/* args */})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for plain function",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "tempfunc": {
    "prefix": "tempfunc",
    "body": "\ntemplate<typename ${1:T}>\n${2:int} ${3:function_name}(${4:/* args */}) noexcept\n{\n\t$0\n}\n",
    "description": "Code snippet for templated function",
    "scope": "source.c++"
  },
  "tempfunca": {
    "prefix": "tempfunca",
    "body": "\ntemplate<typename ${1:T}>\nauto ${2:function_name}(${3:/* args */}) -> decltype(${4:/* expression */})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for template auto function",
    "scope": "source.c++, source.objc++"
  },
  "tempcfunca": {
    "prefix": "tempcfunca",
    "body": "\ntemplate<typename ${1:T}>\nconstexpr auto ${2:function_name}(${3:/* args */}) noexcept -> decltype(${4:/* code */})\n{\n\treturn ${4:/* code */};\n}\n",
    "description": "Code snippet for template auto constexpr function",
    "scope": "source.c++"
  },
  "tempcfunc": {
    "prefix": "tempcfunc",
    "body": "\ntemplate<typename ${1:T}>\nconstexpr ${2:int} ${3:function_name}(${4:/* args */})\n{\n\treturn ${5:/* code */};\n}\n",
    "description": "Code snippet for template constexpr function",
    "scope": "source.c++"
  },

  "bintempfunctor": {
    "prefix": "bintempfunctor",
    "body": "\nstruct ${1:name}\n{\n\ttemplate<typename T, typename U>\n\tconstexpr auto operator()(T&& t, U&& u) const noexcept -> decltype(${2:/* code */})\n\t{\n\t\treturn ${2:/* code */};\n\t}\n};\n",
    "description": "Code snippet for binary template functor",
    "scope": "source.c++"
  },
  "functor": {
    "prefix": "functor",
    "body": "\nstruct ${1:name}\n{\n\t${2:bool} operator()(${3:/* args */}) const noexcept\n\t{\n\t\t${0:/* code */}\n\t}\n};\n",
    "description": "Code snippet for functor",
    "scope": "source.c++"
  },
  "tempfunctor": {
    "prefix": "tempfunctor",
    "body": "\nstruct ${1:name}\n{\n\ttemplate<typename T>\n\tconstexpr auto operator()(T&& t) const noexcept -> decltype(${2:/* code */})\n\t{\n\t\treturn ${2:/* code */};\n\t}\n};\n",
    "description": "Code snippet for unary template functor",
    "scope": "source.c++"
  },

  "lamref": {
    "prefix": "lamref",
    "body": "\n[&](${1:/* args */})\n{\n\t${2:/* code */}\n}\n",
    "description": "Code snippet for lambda – Catch All by Reference",
    "scope": "source.c++, source.c++11"
  },
  "lamval": {
    "prefix": "lamval",
    "body": "\n[=](${1:/* args */})\n{\n\t${2:/* code */}\n}\n",
    "description": "Code snippet for lambda – Catch All by Value",
    "scope": "source.c++, source.c++11"
  },
  "lamfull": {
    "prefix": "lamfull",
    "body": "\n[${1:/* capture */}](${2:/* args */})\n${3:mutable} ${4:noexcept} -> ${5:/* return */}\n{\n\t${6:/* code */}\n}\n",
    "description": "Code snippet for lambda – Full Spec",
    "scope": "source.c++, source.c++11"
  },
  "lamret": {
    "prefix": "lamret",
    "body": "\n[${1:/* capture */}](${2:/* args */}) -> ${3:/* return */}\n{\n\t${4:/* code */}\n}\n",
    "description": "Code snippet for lambda – Explicit Return Declaration",
    "scope": "source.c++, source.c++11"
  },
  "lammin": {
    "prefix": "lammin",
    "body": "\n[${1:/* capture */}]\n{\n\t${2:/* code */}\n}\n",
    "description": "Code snippet for lambda – Minimal",
    "scope": "source.c++, source.c++11"
  },

  "do": {
    "prefix": "do_",
    "body": "\ndo\n{\n\t${0:/* code */}\n} while (${1:/* condition */});\n",
    "description": "Code snippet for do while loop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "for": {
    "prefix": "for",
    "body": "\nfor(${1:size_t} ${2:i} = 0; $2 < ${3:count}; ${4:$2++})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for for loop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "forr": {
    "prefix": "forr",
    "body": "\nfor(int ${1:i} = ${2:length} - 1; $1 >= 0; ${3:$1--})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for reverse for loop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "foreach": {
    "prefix": "foreach",
    "body": "\nfor(${1:object} = ${2:var} in ${3:collection})\n{\n\t${0:/* code */}\n}\n",
    "description": "Code snippet for foreach loop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "forrange": {
    "prefix": "forrange",
    "body": "\nfor(auto&& ${1:i} : ${2:v})\n{\n\t$0\n}\n",
    "description": "Code snippet for range-based forloop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "while": {
    "prefix": "while",
    "body": "\nwhile(${1:/* condition */}){\n\t${2:/* code */}\n}\n",
    "description": "Code snippet for while loop",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },

  "clanggreater": {
    "prefix": "clanggreater",
    "body": "\ndefined(__clang__) && ((__clang_major__ > ${1:3}) || (__clang_major__ == ${1:3}) && (__clang_minor__ >= ${2:2}))\n",
    "description": "Code snippet for Clang version >= check",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "clangless": {
    "prefix": "clangless",
    "body": "\ndefined(__clang__) && ((__clang_major__ < ${1:3}) || (__clang_major__ == ${1:3}) && (__clang_minor__ <= ${2:2}))\n",
    "description": "Code snippet for Clang version <= check",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "gccgreater": {
    "prefix": "gccgreater",
    "body": "\ndefined(__GNUC__) && ((__GNUC__ > ${1:4}) || ((__GNUC__ == ${1:4}) && (__GNUC_MINOR__ >= ${2:7})))\n",
    "description": "Code snippet for GCC version >= Check",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "gccless": {
    "prefix": "gccless",
    "body": "\ndefined(__GNUC__) && ((__GNUC__ < ${1:4}) || ((__GNUC__ == ${1:4}) && (__GNUC_MINOR__ <= ${2:7})))\n",
    "description": "Code snippet for GCC version <= Check",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "ifnd": {
    "prefix": "ifnd",
    "body": "\n#if !defined($1)\n#define ${1:MACRO}\n\n${0}\n\n#endif // $1\n",
    "description": "Code snippet for ifndef ()",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "ifelifpre": {
    "prefix": "ifelifpre",
    "body": "\n#if ${1:/* condition */}\n${2:/* code */}\n#elif ${3:/* condition */}\n${4:/* code */}\n#else\n${0:/* code */}\n#endif\n",
    "description": "Code snippet for #if  #elif  #else",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },
  "ifelsepre": {
    "prefix": "ifelsepre",
    "body": "\n#if ${1:/* condition */}\n${2:/* code */}\n#else\n${0:/*code */}\n#endif\n",
    "description": "Code snippet for #if  #else",
    "scope": "source.c, source.objc, source.c++, source.objc++"
  },

  "cpptraitfun": {
    "prefix": "cpptraitfun",
    "body": "\nstruct ${1:my_trait}_impl\n{\n\ttemplate<typename T, ${$2:/* expression SFINAE here */}>\n\tstatic std::true_type test(int);\n\ttemplate<typename...>\n\tstatic std::false_type test(...);\n};\n\ntemplate<typename T>\nstruct ${1:my_trait} : decltype(${1:my_trait}_impl::test<T>(0)) {};\n$0\n",
    "description": "Code snippet for do while loop",
    "scope": "source.c++"
  },

  "beginend_": {
    "prefix": "beginend_",
    "body": "\nbegin(${1:v}), end(${1:v})\n",
    "description": "Code snippet for std::begin($1), std::end($1)",
    "scope": "source.c++"
  },
  "declv": {
    "prefix": "declv",
    "body": "\nstd::declval<${1:T}>()\n",
    "description": "Code snippet for std::declval<T>()",
    "scope": "source.c++"
  },
  "forw": {
    "prefix": "forw",
    "body": "\nstd::forward<${1:T}>(${2:t})\n",
    "description": "Code snippet for std::forward<T>()",
    "scope": "source.c++"
  },
  "mitl": {
    "prefix": "mitl",
    "body": "\n// The MIT License (MIT)\n\n// Copyright (c) ${1:YEAR} ${2:NAME}\n\n//  Permission is hereby granted, free of charge, to any person obtaining a\n//  copy of this software and associated documentation files (the \"Software\"),\n//  to deal in the Software without restriction, including without limitation\n//  the rights to use, copy, modify, merge, publish, distribute, sublicense,\n//  and/or sell copies of the Software, and to permit persons to whom the\n//  Software is furnished to do so, subject to the following conditions:\n//\n//  The above copyright notice and this permission notice shall be included in\n//  all copies or substantial portions of the Software.\n//\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n//  DEALINGS IN THE SOFTWARE.\n\n${0:/* code */}\n",
    "description": "Code snippet for MIT License",
    "scope": ""
  },
  "namesp": {
    "prefix": "namesp",
    "body": "\nnamespace ${1:name}\n{\n\t$0\n} // $1\n",
    "description": "Code snippet for namespace",
    "scope": "source.c++, source.objc++"
  },
  "returns": {
    "prefix": "returns",
    "body": "\n-> decltype(${1:/* code */})\n{\n\treturn ${1:/* code */};\n}\n",
    "description": "Code snippet for -> decltype()",
    "scope": "source.c++"
  },
  "tem": {
    "prefix": "tem",
    "body": "\ntemplate<typename ${1:T}>\n",
    "description": "Code snippet for template",
    "scope": "source.c++, source.objc++"
  },
  "try": {
    "prefix": "try",
    "body": "\ntry\n{\n\t${1:/* code */}\n}\ncatch(${2:const std::exception& e})\n{\n\t${0:std::cerr << e.what() << '\\n';}\n}\n",
    "description": "Code snippet for try catch block",
    "scope": "source.c++, source.objc++, source.c++11"
  },
  "usings": {
    "prefix": "usings",
    "body": "\nusing ${1:my_type} = ${2:int};\n",
    "description": "Code snippet for using statement",
    "scope": "source.c++"
  },
  "usingt": {
    "prefix": "usingt",
    "body": "\ntemplate<typename ${1:T}>\nusing ${2:Type} = ${3:typename T::type};\n",
    "description": "Code snippet for using statement (templated)",
    "scope": "source.c++"
  },
  "temv": {
    "prefix": "temv",
    "body": "\ntemplate<typename... ${1:Args}>\n",
    "description": "Code snippet for variadic template",
    "scope": "source.c++, source.objc++, source.c++11"
  }
}
